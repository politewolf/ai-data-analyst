"""unique constaint for llms and data source

Revision ID: 7e96b24b33ad
Revises: 9479f7d83f08
Create Date: 2025-11-12 15:55:01.890968

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '7e96b24b33ad'
down_revision: Union[str, None] = 'da68823779da'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Deduplicate names per organization before adding unique constraints.
    # Strategy:
    # - Keep the earliest record (by created_at then id) as-is.
    # - For subsequent duplicates within the same organization, append "-N" suffixes,
    #   choosing the smallest N that does not collide with any existing name.
    conn = op.get_bind()

    def _dedupe(table_name: str) -> None:
        # Fetch all rows ordered to keep the oldest one as the canonical name
        rows = conn.execute(
            sa.text(
                f"""
                SELECT id, organization_id, name, created_at
                FROM {table_name}
                ORDER BY organization_id, name, (created_at IS NULL), created_at, id
                """
            )
        ).mappings().all()

        if not rows:
            return

        # Track all existing names per organization to avoid collisions
        org_to_names: dict[str, set[str]] = {}
        for r in rows:
            org = r["organization_id"]
            nm = r["name"]
            if org not in org_to_names:
                org_to_names[org] = set()
            org_to_names[org].add(nm)

        # Track which (org, name) we've already seen to identify duplicates
        seen_pairs: set[tuple[str, str]] = set()
        updates: list[tuple[str, str]] = []

        for r in rows:
            org = r["organization_id"]
            nm = r["name"]
            pair = (org, nm)
            if pair not in seen_pairs:
                seen_pairs.add(pair)
                continue

            # Duplicate found; generate a unique new name with incremental suffix
            suffix = 1
            while True:
                candidate = f"{nm}-{suffix}"
                if candidate not in org_to_names[org]:
                    break
                suffix += 1
            org_to_names[org].add(candidate)
            updates.append((r["id"], candidate))

        # Apply updates
        for row_id, new_name in updates:
            conn.execute(
                sa.text(f"UPDATE {table_name} SET name = :new_name WHERE id = :id"),
                {"new_name": new_name, "id": row_id},
            )

    _dedupe("data_sources")
    _dedupe("llm_providers")

    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('data_sources', schema=None) as batch_op:
        batch_op.create_unique_constraint('uq_data_sources_org_name', ['organization_id', 'name'])

    with op.batch_alter_table('llm_providers', schema=None) as batch_op:
        batch_op.create_unique_constraint('uq_llm_providers_org_name', ['organization_id', 'name'])

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('llm_providers', schema=None) as batch_op:
        batch_op.drop_constraint('uq_llm_providers_org_name', type_='unique')

    with op.batch_alter_table('data_sources', schema=None) as batch_op:
        batch_op.drop_constraint('uq_data_sources_org_name', type_='unique')

    # ### end Alembic commands ###
